<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/02/01/she-ji-mo-shi/"/>
      <url>/2023/02/01/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/02/01/shu-ju-jie-gou/"/>
      <url>/2023/02/01/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>特点：数据类型相同，地址连续，下表以0开始，数组不擅长插入（添加）和删除元素。数组的优点在于它是连续的，所以查找数据速度很快。但这也是它的一个缺点。正因为它是连续的，所以当插入一个元素时，插入点后所有的元素全部都要向后移；而删除一个元素时，删除点后所有的元素全部都要向前移。</p><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>在方法中定义的一些基本类型的变量和对象的引用变量都在方法的栈内存中分配，当在一段代码中定义一个变量时，java就在栈内存中为这个变量分配内存空间，当超出变量的作用域后，java会自动释放掉为该变量所分配的内存空间。</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆内存用来存放由new运算符创建的对象和数组，在堆中分配的内存，由<a href="https://baike.baidu.com/item/java%E8%99%9A%E6%8B%9F%E6%9C%BA/6810577?fromModule=lemma_inlink">java虚拟机</a>的自动垃圾回收器来管理。在堆中创建了一个数组或对象后，同时还在栈内存中定义一个特殊的变量。让栈内存中的这个变量的取值等于数组或者对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，引用变量实际上保存的是数组或对象在堆内存中的地址（也称为对象的句柄），以后就可以在程序中使用栈的引用变量来访问堆中的数组或对象。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>特点：链表是一种线性存储结构，采用的是链式存储。存储中使用一组任意的存储单元存储线性表的数据，存储单元可以连续，也可以不连续。</p><p>结点：链表中一个数据元素需要存储本身的信息，还需要存储直接后继的存储位置，这两部分构成结点（node）。</p><p>换种方式来说，一个结点需要包含两部分内容，数据域和指针域。</p><p>数据域：存储数据元素信息</p><p>指针域：存储直接后继的存储位置</p><p>头指针：<br>整个链表的存取必须从头指针开始，头指针存储了链表中的第一个结点的地址</p><p>头结点：<br>在单链表的第一个结点之前附设一个结点，称为头结点。</p><p>头结点的<strong>数据域可以不存储任何信息</strong>。头结点的<strong>指针域存储首元结点的地址</strong>。</p><p>首元节点：</p><p>首元结点是指链表中存储<strong>第一个数据元素的结点</strong>。</p><img src="/2023/02/01/shu-ju-jie-gou/image-20230201102713328.png" class=""><p>循环<strong>链表</strong>与单链表不同的是，最后一个结点的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>是指向该循环<strong>链表</strong>的第一个结点或者表头结点，从而构成一个环形的链。</p><p>循环<strong>链表</strong>的运算与单<strong>链表</strong>的运算基本一致。所不同的有以下几点：</p><p>1、在建立一个循环<strong>链表</strong>时，必须使其最后一个结点的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>指向表头结点，而不是象单<strong>链表</strong>那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。</p><p>2、在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>时，说明已到表尾。而非象单<strong>链表</strong>那样判断链域值是否为NULL。</p><p>双向<strong>链表</strong>是单<strong>链表</strong>的改进。</p><p>在双向<strong>链表</strong>中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO）</p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><h5 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h5><p>定义一个数组a[N]，并设置两个指针进行管理。一个指针为<strong>front</strong>指向队头，一个指针为<strong>rear</strong>指向队尾。当元素入队时，rear加一，当元素出队时 front+1。</p><p>可能出现情况</p><p>假溢出：指队列进行多次入队与出队操作之后，rear已经指向数组最后一个位置，但队列并没有被填满，如果再插入新的元素，就会超过数组的长度，这种溢出我们称为假溢出。</p><p>真溢出：指队列进行多次入队与出队操作之后，rear已经指向数组最后一个位置，并且此时队列已经被填满，如果再插入新的元素，就会超过数组的长度，这种溢出我们称为真溢出。</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>为了解决假溢出这个情况就有了循环队列，逻辑上首尾相连</p><p>入队：队尾循环后移， rear =（rear+1）%Maxsize;<br>出队：队首循环后移， front =（front+1）%Maxsize;<br>队空：front=rear; // rear 和 front 指向同一个位置<br>队满:(rear+1) %Maxsize=front; // rear 向后移一位正好是 front</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是允许在同一端进行插入和删除操作的特殊<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8?fromModule=lemma_inlink">线性表</a>。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为<a href="https://baike.baidu.com/item/%E8%BF%9B%E6%A0%88?fromModule=lemma_inlink">进栈</a>（PUSH），删除则称为退栈（POP）。栈也称为先进后出表（LIFO）。</p><p>栈可以用来在<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0?fromModule=lemma_inlink">函数</a>调用的时候存储断点，做递归时要用到栈。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树（Tree）</strong>是n（n&gt;=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中： 1）有且仅有一个特定的称为根（Root）的结点； 2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。</p><p>此外，树的定义还需要强调以下两点： 1）根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。 2）子树的个数没有限制，但它们一定是互不相交的。<br>度数：结点拥有的子树数目称为结点的度。</p><p>从根开始定义起，根为第一层，根的孩子为第二层，以此类推。</p><p>树中结点的最大层次称为树的深度。</p><h3 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h3><p>在二叉树的第i层上最多有 2^i-1 个节点 。<br>二叉树中如果深度为k,那么最多有2^k-1个节点。(k&gt;=1）<br>n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。<br>在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整<br>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>特点有：</p><ul><li>叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</li><li>非叶子结点的度一定是2。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。编号跟满二叉树一样的</p><p>特点：</p><p>叶子结点只能出现在最下层和次下层。<br>最下层的叶子结点集中在树的左部。<br>倒数第二层若存在叶子结点，一定在右部连续位置。<br>如果结点度为1，则该结点只有左孩子，即没有右子树。<br>同样结点数目的二叉树，完全二叉树深度最小。 注：满二叉树一定是完全二叉树，但反过来不一定成立。</p><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引</p><img src="/2023/02/01/shu-ju-jie-gou/image-20230201121722498.png" class=""><h5 id="二叉链表存储"><a href="#二叉链表存储" class="headerlink" title="二叉链表存储"></a>二叉链表存储</h5><p>既然顺序存储不能满足二叉树的存储需求，那么考虑采用链式存储。由二叉树定义可知，二叉树的每个结点最多有两个孩子。因此，可以将结点数据结构定义为一个数据和两个指针域。</p><img src="/2023/02/01/shu-ju-jie-gou/image-20230201121859006.png" class=""><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p>后序遍历：上到下，左到右</p><h4 id="二叉查找树（又叫做二叉搜索树，二叉排序树）"><a href="#二叉查找树（又叫做二叉搜索树，二叉排序树）" class="headerlink" title="二叉查找树（又叫做二叉搜索树，二叉排序树）"></a>二叉查找树（又叫做二叉搜索树，二叉排序树）</h4><p>特征：</p><ul><li>每一个节点左边的节点键值都比根节点小，每一个节点右边的节点键值都比根节点大</li><li>没有键值相等的节点。</li></ul><img src="/2023/02/01/shu-ju-jie-gou/image-20230201122502493.png" class=""><h4 id="平衡二叉树（AVL树"><a href="#平衡二叉树（AVL树" class="headerlink" title="平衡二叉树（AVL树)"></a>平衡二叉树（AVL树)</h4><p>含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树</p><p>特点：</p><p>要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1<br>其左右子树也都是平衡二叉树<br>叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p><p>性质：</p><p>每个结点不是红色就是黑色<br>根节点是黑色的<br>如果一个节点是红色的，则它的两个孩子结点是黑色的<br>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点<br>每个叶子结点都是黑色的</p><h4 id="B-树（也叫B树）"><a href="#B-树（也叫B树）" class="headerlink" title="B-树（也叫B树）"></a>B-树（也叫B树）</h4><p>B-树是一种平衡多路查找树，它在文件系统中很有用。</p><p>一棵m阶B-树，具有下列性质：</p><p>树中每个节点至多有m棵子树<br>若根节点不是叶子节点，则至少有2棵子树<br>除根节点之外的所有非终端节点至少有棵子树；<br>每个节点中的信息结构为（A0,K1,A1,K2…Kn,An），其中n表示关键字个数，Ki为关键字，Ai为指针<br>所有的叶子节点都出现在同一层次上，且不带任何信息，也是为了保持算法的一致性。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+数是B-树的一种变形，它与B-树的差别在于）：</p><p>有n棵子树的节点含有n个关键字<br>所有的叶子节点包含了全部关键字的信息，及指向这些关键字记录的指针，且叶子节点本身按关键字大小自小到大顺序链接<br>所有非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中最大（或最小）关键字，所有B+树更像一个索引顺序表<br>对B+树进行查找运算，一是从最小关键字起进行顺序查找，二是从根节点开始，进行随机查找。</p><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h4><p>在b+树的基础上，在非根节点和非叶子节点的层级上，为每一个叶子节点添加指向下一个兄弟节点的指针</p><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树</p><p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：</p><ol><li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li><li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li><li>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习</title>
      <link href="/2022/12/05/spring-xue-xi/"/>
      <url>/2022/12/05/spring-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>简化java开发</p><p>为了降低java开发的复杂性，Spring采取了以下4种关键策略：</p><p>基于POJO的轻量级和最小入侵性编程；</p><p>通过依赖注入和面向接口实现解耦；</p><p>基于切面和惯例进行声明式编程；</p><p>通过切面和模板减少样式模板代码；</p><h2 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h2><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</p><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span>{</span><br><span class="line"><span class="keyword">private</span> C c;</span><br><span class="line">    <span class="keyword">public</span> A{</span><br><span class="line">        <span class="built_in">this</span>.c = <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，在A的构造函数中创建了C对象，使得A和C这两个类高耦合在了一起</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span>{</span><br><span class="line"><span class="keyword">private</span> C c;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(C c)</span>{<span class="comment">//C被注入进来</span></span><br><span class="line">        <span class="built_in">this</span>.c = c; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>A没有创建C，而是在构造的时候将C作为参数传入</p><p>这就是依赖注入的一种方式（构造器注入）</p><p>这就是DI所带来的最大收益——松耦合。如果一个对象只通过接口（而不是具体实现或初始化过程）来表明依赖关系，那么这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现进行替换。</p><h3 id="xml实现"><a href="#xml实现" class="headerlink" title="xml实现"></a>xml实现</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">'knight'</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.BraveKnig"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"quest"</span>/&gt;</span>//注入Quest been</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">'quest'</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.SlayDragonQuest"</span>&gt;</span>//创建SlayDragonQuest对象</span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#{T{System}.out}"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>BraveKnight和SlayDragonQuest被声明为Spring中的bean。就BraveKnight bean来讲，它在构造时传入了对SlayDragonQuest bean的引用，将其作为构造器参数。同时，SlayDragonQuest bean的声明使用了Spring表达式语言（Spring Expression Language），将System.out（这是一个PrintStream）传入到了SlayDragonQuest的构造器中。</p><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnightConfig</span>(){</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Knight <span class="title function_">knight</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BraveKnight</span>(quest());</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Quest <span class="title function_">quest</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SlayDragonQuest</span>(System.out);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>Spring通过Application Context 加载 bean对象并把他们组装起来。Spring</p><p>有多种Application Context的实现，它们之间主要的区别仅仅在于如何加载配置。</p><p>比如，通过xml文件来进行配置的话，会选择ClassPathXmlApplicationContext作为加载的应用上下文（Application Context）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"beans.xml"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="面向切面（AOP）"><a href="#面向切面（AOP）" class="headerlink" title="面向切面（AOP）"></a>面向切面（AOP）</h2><p>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程（aspect-oriented programming，AOP）允许你把遍布应用各处的功能分离出来 形成可重用的组件</p><p>面向切面编程往往被定义为促使软件系统实现关注点的分离一项技术。系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实 现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的 组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。 如果将这些关注点分散到多个组件中去，你的代码将会带来双重的复杂性。</p><img src="/2022/12/05/spring-xue-xi/image-20221205204301337-16702441840361.png" class="" title="image-20221205204301337"><p>通俗来说就是将大家要用到的资源模块抽离出来，谁要用就谁用，通过声明的方式应用到要用的组件中，使得这些组件会有更高的内聚并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。</p><h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><p>在Spring的应用中，Spring容器管理着应用对象的整个生命周期。从生存到死亡。Spring容器可以归纳为两种类型，bean工厂（由org.springframework. beans. factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。应用上下文 （由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从 属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。不过一般都是用应用上下文 。</p><h2 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h2><p>Spring有多种类型的应用上下文，比如：</p><h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p>从一个或多个基于Java的配置类中加载Spring应用上下文</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(bean.class);</span><br></pre></td></tr></tbody></table></figure><p>独立的应用程序上下文，接受组件类作为输入—特别是@ configuration注释类，但也可以使用javax接受@Component类型和符合JSR-330的类。 注入注解。 </p><p>允许使用register(Class…)逐个注册类，也允许使用scan(String…)扫描类路径。 </p><p>如果有多个@Configuration类，后面的类中定义的@Bean方法将覆盖前面类中定义的方法。 这可以通过一个额外的@Configuration类来有意地覆盖某些bean定义。</p><p>就是扫描资源路径下被@Configuration标注的类，并将其被@Bean标注的方法注册到容器中，如果有多个配置类的话，前面的配置类中与后面的配置类有相同的Bean_id的话会被覆盖，从而实现配置管理</p><h3 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a>AnnotationConfigWebApplicationContext</h3><p>从一个或多个基于Java的配置类中加载Spring Web应用上下文</p><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"bean.xml"</span>);</span><br></pre></td></tr></tbody></table></figure><p>从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</p><p>独立的 XML 应用程序上下文，从类路径中获取上下文定义文件，将纯路径解释为包含包路径的类路径资源名称（例如“mypackagemyresource.txt”）。对于测试工具以及嵌入在 JAR 中的应用程序上下文非常有用。配置位置默认值可以通过getConfigLocations覆盖，配置位置可以表示具体文件，如“myfilescontext.xml”或Ant风格的模式.注： 如果有多个配置位置，后面的 Bean 定义将覆盖在早期加载的文件中定义的 Bean。可以利用这一点，通过额外的 XML 文件故意覆盖某些 Bean 定义。这是一个简单、一站式的便利应用程序上下文。考虑将 GenericApplicationContext 类与 org.springframework.beans.factory.xml.XmlBeanDefinitionReader 结合使用，以实现更灵活的上下文设置。</p><h3 id="FileSystemXmlapplicationcontext"><a href="#FileSystemXmlapplicationcontext" class="headerlink" title="FileSystemXmlapplicationcontext"></a>FileSystemXmlapplicationcontext</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">"C:/bean.xml"</span>);</span><br></pre></td></tr></tbody></table></figure><p>从文件系统下的一个或多个XML配置文件中加载上下文定义</p><p>独立的XML应用程序上下文，从文件系统或url获取上下文定义文件，将普通路径解释为相对的文件系统位置(例如。 “mydir / myfile.txt”)。 对于测试工具和独立环境都很有用。 注意:普通路径将始终被解释为相对于当前VM工作目录，即使它们以斜杠开头。 (这与Servlet容器中的语义一致。) 使用显式的“file:”前缀强制使用绝对文件路径。 配置位置的默认值可以通过getConfigLocations来覆盖，配置位置既可以表示具体的文件，如”/myfiles/context.xml”，也可以表示ant样式的模式，如”/myfiles/*-context.xml”注意:在多个配置位置的情况下，以后的bean定义将覆盖早期加载文件中定义的定义。 可以利用这一点，通过额外的XML文件故意覆盖某些bean定义。 这是一个简单的，一站式商店方便的ApplicationContext。 考虑将GenericApplicationContext类与org.springframework.beans.factory.xml.XmlBeanDefinitionReader结合使用，以获得更灵活的上下文设置。 </p><h3 id="XmlWebApplicationContext"><a href="#XmlWebApplicationContext" class="headerlink" title="XmlWebApplicationContext"></a>XmlWebApplicationContext</h3><p>从Web应用下的一个或多个XML配置文件中加载上下文定义</p><p>独立的应用程序上下文，接受组件类作为输入 — 特别是@Configuration注释类，但也包括使用 javax.inject 注释的纯@Component类型和符合 JSR-330 的类。<br>允许使用寄存器（类…）逐个注册类，以及使用扫描（字符串…）进行类路径扫描。<br>在有多个@Configuration类的情况下，后面类中定义@Bean方法将覆盖早期类中定义的方法。可以利用这一点，通过额外的@Configuration类故意覆盖某些 Bean 定义。</p><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用， 则由Java自动进行垃圾回收。 相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。</p><img src="/2022/12/05/spring-xue-xi/image-20221206175904117-16703207452381.png" class="" title="image-20221206175904117"><p>1．Spring对bean进行实例化； </p><p>2．Spring将值和bean的引用注入到bean对应的属性中； </p><p>3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法； </p><p>4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p><p> 5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的 引用传入进来； 6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法； </p><p>7．如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用； </p><p>8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法； </p><p>9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁； </p><p>10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销 毁方法，该方法也会被调用。</p><h2 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h2><img src="/2022/12/05/spring-xue-xi/image-20221206180429333-16703210708552.png" class="" title="image-20221206180429333"><h3 id="Spring核心容器"><a href="#Spring核心容器" class="headerlink" title="Spring核心容器"></a>Spring核心容器</h3><p>容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Spring bean工厂，它为Spring提供了 DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。 除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。 所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式地使用了这些类。</p><h3 id="Spring的AOP模块"><a href="#Spring的AOP模块" class="headerlink" title="Spring的AOP模块"></a>Spring的AOP模块</h3><p>在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象 解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。</p><h3 id="数据访问与集成"><a href="#数据访问与集成" class="headerlink" title="数据访问与集成"></a>数据访问与集成</h3><p>使用JDBC编写代码通常会导致大量的样板式代码，例如获得数据库连接、创建语句、处理结果集到最后关闭数据库连接。Spring的JDBC和 DAO（Data Access Object）模块抽象了这些样板式代码，使我们的数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的 问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL错误信息了！ 对于那些更喜欢ORM（Object-Relational Mapping）工具而不愿意直接使用JDBC的开发者，Spring提供了ORM模块。Spring的ORM模块建立 在对DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式。Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的 ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框 架以及JDBC。</p><h3 id="Web与远程调用"><a href="#Web与远程调用" class="headerlink" title="Web与远程调用"></a>Web与远程调用</h3><p>MVC（Model-View-Controller）模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离。Java从来不缺少 MVC框架，Apache的Struts、JSF、WebWork和Tapestry都是可选的最流行的MVC框架。 虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，有助于在Web层提升应用的松耦 合水平。 除了面向用户的Web应用，该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTP invoker。Spring还提供了暴露和使用REST API的 良好支持。</p><h2 id="Spring版本特性"><a href="#Spring版本特性" class="headerlink" title="Spring版本特性"></a>Spring版本特性</h2><h3 id="Spring-3-1新特性"><a href="#Spring-3-1新特性" class="headerlink" title="Spring 3.1新特性"></a>Spring 3.1新特性</h3><p>Spring 3.1引入了环境profile功能，能根据应用部署在什么环境之中选择不同的数据源bean；</p><p>添加了多个enable注解，能使用这个注解启用Spring的特定功能</p><p>支持声明式缓存</p><p>新添加的用于构造器注入的c命名空间，它类似于Spring 2.0所提供的面向属性的p命名空间，p命名空间用于属性注入，</p><p>支持Servlet 3.0，包括在基于Java的配置中声明Servlet和Filter，而不再借助于web.xml</p><p>改善Spring对JPA的支持，使得它能够在Spring中完整地配置JPA</p><p>提供了@RequestMappingproduces和consumes属性，用于匹配请求中的Accept和Content-Type头部信息</p><p>提供了@RequestPart注解，用于将multipart请求中的某些部分绑定到处理器的方法参数中</p><h3 id="Spring-3-2新特性"><a href="#Spring-3-2新特性" class="headerlink" title="Spring 3.2新特性"></a>Spring 3.2新特性</h3><p>Spring 3.2的控制器（Controller）可以使用Servlet 3.0的异步请求，允许在一个独立的线程中处理请求，从而将Servlet线程解放出来处理 更多的请求；</p><p>@ControllerAdvice注解能够将通用的@ExceptionHandler、@ InitBinder和@ModelAttributes方法收集到一个类中，并 应用到所有控制器上</p><p>Spring MVC 3.2包含了一个新的@MatrixVariable注解，这个注解能够将请求中的矩阵变量（matrix variable）绑定到处理器的方法参 数中；</p><p>RestTemplate和@RequestBody的参数可以支持范型</p><p>RestTemplate和@RequestMapping可以支持HTTP PATCH方法；</p><p>在拦截器匹配时，支持使用URL模式将其排除在拦截器的处理功能之外</p><p>@Autowired、@Value和@Bean注解能够作为元注解，用于创建自定义的注入和bean声明注解</p><p>@DateTimeFormat注解不再强依赖JodaTime。如果提供了JodaTime，就会使用它，否则的话，会使用SimpleDateFormat；</p><h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><p>Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系,但Spring要创建哪些bean并且如何将其装配在一起呢？</p><h3 id="纯注解自动化装配bean"><a href="#纯注解自动化装配bean" class="headerlink" title="纯注解自动化装配bean"></a>纯注解自动化装配bean</h3><p>Spring从两个角度来实现自动化装配：</p><p> 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</p><p> 自动装配（autowiring）：Spring自动满足bean之间的依赖。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//@Component注解就是将User类加载到spring容器中，类似于配置了一个bean对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="meta">@Value("哈哈")</span> <span class="comment">//@Value注解相当于在property标签中的为属性注入值</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span><span class="comment">// @Configuration代表这个类是一个配置类和xml配置文件一样</span></span><br><span class="line"><span class="meta">@ComponentScan</span><span class="comment">//@ComponentScan注解就是扫描包下的所有注解</span></span><br><span class="line">Import(orderConfig.class)<span class="comment">//可以通过这个注解引入其它的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JieConfig</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注册一个bean，就是相当于我们之前在xml配置文件写的bean</span></span><br><span class="line"><span class="comment">        方法的名字就是bean的id，返回值就是bean的class属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="在Java-xml中进行显式配置"><a href="#在Java-xml中进行显式配置" class="headerlink" title="在Java+xml中进行显式配置"></a>在Java+xml中进行显式配置</h3><p>需要在pom文件中导入依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring 容器包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;${org.springframework.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在xml中开启配置注解支持</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">&lt;!-- 启用自动装配注解支持 --&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在xml中写上你要用的bean,在java代码中使用@Autowired标注</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2022/12/04/xuan-ze-pai-xu/"/>
      <url>/2022/12/04/xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>① 第一轮从下标为 1 到下标为 n-1 的元素中选取最小值，若小于第一个数，则交换<br>② 第二轮从下标为 2 到下标为 n-1 的元素中选取最小值，若小于第二个数，则交换<br>③ 依次类推下去……</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="type">int</span> i, j, min, temp, len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) {<span class="comment">//循环的次数</span></span><br><span class="line">        min = i;<span class="comment">//记录最小值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++){<span class="comment">//每次循环要比较的次数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">                min = j;<span class="comment">//找到最小值位置的索引</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//每次找到最小值后进行交换</span></span><br><span class="line">        temp = arr[min];</span><br><span class="line">        arr[min] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n2)</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2022/12/04/mou-pao-pai-xu/"/>
      <url>/2022/12/04/mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个一维数组，里面有多个数，如何将数组里面的数排序？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将要排序的数进行两两比较，每次确定一个（最大值或最小值由你决定），然后在剩下的数中进行上述步骤</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以数组从小到大排序为例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++){<span class="comment">// array.length-1 表示 要循环的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++){<span class="comment">// array.length-1-i 表示 每次循环要比较的次数</span></span><br><span class="line">        <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>]){</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">            array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">            array[j+<span class="number">1</span>] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>因为有两个for循环所以是：O(n2)</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>因为有临时辅助空间temp所以是：O(1)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security学习</title>
      <link href="/2022/12/04/spring-security-xue-xi/"/>
      <url>/2022/12/04/spring-security-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现 对用户访问系统的控制 ，按照 安全规则 或者 安全策略 控制用户可以访问而且只能访问自己被授权的资源。权限管理包括用户身份<strong>认证</strong>和<strong>授权</strong>两部分，简称<strong>认证授权</strong>。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>身份认证就是判断一个用户是否为合法用户的处理过程，最简单的认证就是系统通过核对用户输入的用户名和口令，是否正确。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权就是访问控制，控制用户允许访问的资源。进行身份认证后需要进行权限的分配才能访问系统的资源，对于某些资源是没有资格访问的。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>在java的企业级开发中，安全管理框架很少，常见的就是：</p><h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><p>Shiro是一个老牌的安全管理框架，优点：轻量级,简单，易于集成，可以在javase环境中使用。不过在微服务时代就显得力不从心。</p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>公司自己开发的安全管理框架，不仅仅包括登录和权限管理这么简单，还有对于网络攻击和防御的策略，大公司才会有能力开发</p><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>SpringSecurity是Spring家族的一员，在Spring时代有着无可替代的地位，同时支持OAuth2,如SpringCloud Security是微服务项目的首要选择。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><img src="/2022/12/04/spring-security-xue-xi/image-20221204163410704.png" class=""><p>在SpringSecurity中认证<strong>Authentication</strong>和授权<strong>Authorization</strong>是分开的，也就是说无论你用什么方式认证都不会影响到你的授权。</p><h3 id="认证-1"><a href="#认证-1" class="headerlink" title="认证"></a>认证</h3><p>在Spring Security中认证是由AuthenticationManager接口来负责，</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> {</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">尝试对传递的身份验证对象进行身份验证，如果成功，则返回完全填充的身份验证对象（包括授予的权限）。</span></span><br><span class="line"><span class="comment">身份验证管理器必须履行以下有关异常的合同：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果帐户被禁用，则必须引发 DisabledException，并且 AuthenticationManager 可以测试此状态。</span></span><br><span class="line"><span class="comment">如果帐户被锁定，则必须抛出 LockedException，并且 AuthenticationManager 可以测试帐户锁定。</span></span><br><span class="line"><span class="comment">如果提供不正确的凭据，则必须引发错误凭据异常。虽然上述例外是可选的，但身份验证管理器必须始终测试凭据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">应测试异常，如果适用，应按上述顺序抛出（即，如果帐户被禁用或锁定，则身份验证请求将立即被拒绝，并且不执行凭据测试过程）。这可以防止针对已禁用或锁定的帐户测试凭据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">形参:</span></span><br><span class="line"><span class="comment">authentication – the authentication request object</span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment">a fully authenticated object including credentials</span></span><br><span class="line"><span class="comment">抛出:</span></span><br><span class="line"><span class="comment">AuthenticationException – if authentication fails</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">形参:</span></span><br><span class="line"><span class="comment">身份验证 – 身份验证请求对象</span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment">经过完全身份验证的对象，包括凭据</span></span><br><span class="line"><span class="comment">抛出:</span></span><br><span class="line"><span class="comment">身份验证异常 – 如果身份验证失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>AuthenticationManager 主要实现类为 ProviderManager，ProviderManager 中管理了众多AuthenticationProvider 实例。在一次完整的认证流程中，Spring Security 允许存在多个AuthenticationProvider ，用来实现多种认证方式，这些AuthenticationProvider 都是由ProviderManager 进行统一管理的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识</title>
      <link href="/2022/12/03/java-ji-chu-zhi-shi/"/>
      <url>/2022/12/03/java-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p>​        Java 的历史要追溯到 1991 年，由 Patrick Naughton 和 James Gosling (一个全能的计算机 奇才）带领的 Sun 公司的工程师小组想要设计一种小型的计算机语言， 主要用于像有线电视 转换盒这类的消费设备。由于这些消费设备的处理能力和内存都很有限， 所以语言必须非常 小且能够生成非常紧凑的代码。另外， 由于不同的厂商会选择不同的中央处理器（ CPU), 因 此这种语言的关键是不与任何特定的体系结构捆绑在一起。这个项目被命名为“ Green”。 </p><p>​        代码短小、 紧凑且与平台无关， 这些要求促使开发团队设计一个可移植的语言， 可以为 虚拟机生成中间代码。 不过， Sun 公司的人都有 UNIX 的应用背景。因此， 所开发的语言以 C++ 为基础， 而不 是 Lisp、 Smalltalk 或 Pascal。不过， 就像 Gosling 在专访中谈到的：“ 毕竟，语言只是实现目 标的工具，而不是目标本身”。Gosling 把这种语言称为“ Oak ”（这么起名的原因大概是因为 他非常喜欢自己办公室外的橡树)。Sun 公司的人后来发现 Oak 是一种已有的计算机语言的 名字，于是， 将其改名为 Java。 事实证明这是一个很有灵感的选择。 </p><p>​        1992 年， Green 项目发布了它的第一个产品，称之为“ *7”。这个产品具有非常智能的 远程控制。遗憾的是， Sun 公司对生产这个产品并不感兴趣， Green 项目组的人员必须找出 其他的方法来将他们的技术推向市场。然而， 没有一个标准消费品电子公司对此感兴趣。于 是，Green 项目组竞标了一个提供视频点播等新型服务的有线电视盒的项目，但没有成功（有 趣的是，得到这个项目的公司的领导恰恰是开创 Netscape 公司的 Jim Clark。Netscape 公司后 来对 Java 的成功给予了很大的帮助）。</p><p>​        Green 项目（这时换了一个新名字—“ First Person 公司”） 花费了 1993 年一整年 以及 1994 年的上半年， 一直在苦苦寻求其技术的买家。然而，一个也没有找到（ Patrick Naughton, 项目组的创立人之一，也是完成此项目大多数市场工作的人，声称为了销售这项 技术， 累计飞行了 300 000 英里）。1994 年 First Person 公司解散了。</p><p>​        当这一切在 Sun 公司发生的时候， Internet 的万维网也在日渐发展壮大。万维网的关键 是把超文本页面转换到屏幕上的浏览器。1994 年大多数人都在使用 Mosaic, 这是一个 1993 8 Java 核心技木 年出自伊利诺斯大学超级计算中心的非商业化的 Web 浏览器（ Mosaic 的一部分是由 Marc Andreessen 编写的。当时， 他作为一名参加半工半读项目的本科生， 编写了这个软件， 每小时 的薪水只有 6.85 美元。他后来成了 Netscape 公司的创始人之一和技术总监， 可谓名利双收。) </p><p>​        在接受 SunWorld 采访的时候，Gosling 说在 1994 年中期， Java 语言的开发者意识到： “ 我们能够建立一个相当酷的浏览器。我们已经拥有在客户机 / 服务器主流模型中所需要的体 系结构中立、实时、 可靠、 安全—这些在工作站环境并不太重要， 所以， 我们决定开发浏 ，览器 实际的浏览器是由 Patrick Naughton 和 Jonathan Payne 开发的， 并演变为 HoUava 浏览 器。 为了炫耀 Java 语言超强的能力， HoUava 浏览器采用 Java 编写。设计者让 HoUava 浏览 器具有在网页中执行内嵌代码的能力。 这一“ 技术印证” 在 1995 年 5 月 23 日的 SunWorld 上得到展示， 同时引发了人们延续至今的对 Java 的狂热追逐。         </p><p>​        1996 年年初，Sun 发布了 Java 的第 1 个版本： 人们很快地意识到 Java1.0 不能用来进行 真正的应用开发。的确， 可以使用 Java 1.0 来实现在画布上随机跳动的神经质的文本 applet， 但它却没有提供打印功能。 坦率地说， Java 1.0 的确没有为其黄金时期的到来做好准备。后 来的 Java 1丨弥补了其中的大多明显的缺陷 . ， 大大改进了反射能力，并为 GUI 编程增加了新 的事件处理模型：不过它仍然具有很大的局限性。</p><p>​        1998 年 JavaOne 会议的头号新闻是即将发布 Java 1.2 版。这个版本取代了早期玩具式的 GUI, 并且它的图形T.具箱更加精细而具有可伸缩性，更加接近“ 一次编写， 随处运行” 的 承诺,， 在 1998 年 12 月 Java 1.2 发布 7天之后， Sun 公司市场部将其名称改为更加吸引人的 “ Java 2 标准版软件开发工具箱丨.2 版”。 除了‘ 标准版’ 之外，Sun 还推出了两个其他的版本：一个是用于手机等嵌人式设备的‘ 微 型版”；另一个是用于服务器端处理的“ 企业版”。 标准版的 1.3 和 1.4 版本对最初的 Java 2 版本做出了某些改进， 扩展了标准类库，提高 系统性能。 当然，还修正了一些 bug。在此期间， Java applet 采用低调姿态，并淡化了客户 端的应用，但 Java 却成为服务器端应用的首选平台。</p><p>​        5.0 版是自 1.1 版以来第一个对 Java 语言做出重大改进的版本（这一版本原来被命名为 1.5 版，在 2004 年的 JavaOne 会议之后，版本数字升至 5.0 )。经历了多年的研究，这个版本 添加了泛型类型（generic type )(类似于 C++ 的模板，) 其挑战性在于添加这一特性并没有对虚 拟机做出任何修改。 另外， 还有几个受 C# 启发的很有用的语言特性：“ for each” 循环、 自 动装箱和注解。 版本 6 ( 没有后缀 .0 ) 于 2006 年年末发布。 同样，这个版本没有对语言方面再进行改进。 但是，改进了其他性能，并增强了类库。 随着数据中心越来越依赖于商业硬件而不是专用服务器，Sun Microsystems 终于沦陷， 于 2009 年被 Oracle 收购 _ Java 的开发停滞了很长一段时间。直到 201丨年 Oracle 发布了 Java 的一个新版本，Java ?, 其中只做了一些简单的改进。</p><p>​        2014 年 ,Java 8终于发布，在近 20 年中这个版本有了最大的改变。Java 8 提供了一种“ 函 第 / 章 Java 程 序 ? ? 概 述 9 数式” 编程方式，可以很容易地表述并发执行的计算。 所有编程语言都必须与时俱进，Java 在这方面显示出非凡的能力。</p><p>​        表 1-1 展示了 Java 语言以及类库的发展状况。可以看到，应用程序编程接口（API) 的规 模发生了惊人的变化。</p><img src="/2022/12/03/java-ji-chu-zhi-shi/image-20221203104849775-16700357344601.png" class=""><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="JDK下载"><a href="#JDK下载" class="headerlink" title="JDK下载"></a>JDK下载</h3><p>JVM：java虚拟机</p><p>JRE： 包含虚拟机 但不包含编译器</p><p>JDK： 包含虚拟机 和编译器</p><p>普通用户要想运行java程序至少需要安装JRE，开发者要安装JDK</p><p>下载地址：<a href="https://www.oracle.com/cn/java/technologies/downloads/">Java Downloads | Oracle 中国</a></p><p>建议：下载速度慢的话可以百度搜索一下 <a href="https://www.baidu.com/s?wd=JDK%E4%B8%8B%E8%BD%BD&amp;rsv_spt=1&amp;rsv_iqid=0xe19e03c800003513&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ib&amp;rsv_sug3=2&amp;rsv_n=2">JDK下载_百度搜索 (baidu.com)</a>网上有各位小伙伴发出来的</p><h3 id="JDK设置"><a href="#JDK设置" class="headerlink" title="JDK设置"></a>JDK设置</h3><p>在 Windows 或 Linux 上安装 JDK 时， 还需要另外完成一个步骤：将如目录jdk/bin增加到 执行路径中一执行路径是操作系统查找可执行文件时所遍历的目录列表(也就是添加环境变量)</p><p>在 Linux 上，需要在 ~/.bashrc 或 ~/.bash_profile 文件的最后增加这样一行： </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/ d/t/bin:$PATH</span><br></pre></td></tr></tbody></table></figure><p>在 Windows10（以这个版本为例） 上， –&gt;我的电脑右键–&gt;高级系统设置–&gt;属性–&gt; 环境变量–&gt;系统变量–&gt;新建</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名：JAVA_HOME</span><br><span class="line">值："c:\ProgramFiles\Java\jdkl.8.0_31\</span><br></pre></td></tr></tbody></table></figure><p>然后在PATH系统变量中添加</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></tbody></table></figure><h3 id="多个JDK冲突"><a href="#多个JDK冲突" class="headerlink" title="多个JDK冲突"></a>多个JDK冲突</h3><p>在PATH变量中把你想要的用的JDK版本放在开头就行了</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在命令行中输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><p>出现版本信息表示环境搭建成功</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>当你使用命令行运行Java文件时</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Filename.java  //javac是编译命令，生成字节码文件.class</span><br><span class="line">java Filename //java是运行命令</span><br></pre></td></tr></tbody></table></figure><p>如果出现这样的错误</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac: command not found</span><br><span class="line">The name specified is not recognized as an internal or external command, operable program or batch file (指定名不</span><br><span class="line">是一个内部或外部命令、 可执行的程序或批文件，) </span><br></pre></td></tr></tbody></table></figure><p>就需要退回去反复检査你的安装</p><h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>大多数的公司都在用eclipse或者idea这两款开发工具，其中eclipse是免费的，idea是收费的，不过可以破解，这里不提供破解方法（百度一下，你就知道）</p><p>eclipse下载地址：<a href="https://www.eclipse.org/downloads/">Eclipse Downloads | The Eclipse Foundation</a></p><p>idea下载地址：<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA – the Leading Java and Kotlin IDE (jetbrains.com)</a></p><h2 id="Java的基本程序结构"><a href="#Java的基本程序结构" class="headerlink" title="Java的基本程序结构"></a>Java的基本程序结构</h2><h3 id="简单的java程序"><a href="#简单的java程序" class="headerlink" title="简单的java程序"></a>简单的java程序</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstSample</span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">System.out.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>java是严格区分大小写的，其中关键字 public 称为访问修饰符（access modifier), 这 些修饰符用于控制程序的其他部分对这段代码的访问级別</p><p>关键字 class 表明 Java 程序中的全部内容都包含在类中</p><p>关键字 class 后面紧跟类名定义类名的规则很宽松。名字必须以字母开头，后 面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用 Java 保留字（例如， public 或 class) 作为类名</p><p>强烈建议使用使用驼峰的形式命名：类名是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写例如：CamelCase</p><p>源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名。因此，存储这段源代 码的文件名必须为 FirstSample.java</p><p>每个 Java 应用程序都 必须有一个 main 方法，main方法作为程序的入口必须为public （详解见java虚拟机规范，JVM 找不到 main 方法就抛出 NoSuchMethodError:main 异常）</p><p>Java 中任何方法的代码都用“ {” 开始，用”}”结束。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 是 一种强类型语言。这就意味着必须为每一个变量声明一种类型: 在 Java 中，一共有 8 种基本类型（ primitive type ), 其中有 4 种整型、2 种浮点类型、 1 种用于表示 Unicode 编码的字符 单元的字符类型 char 和 1 种用于表示真值的 boolean 类型</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><img src="/2022/12/03/java-ji-chu-zhi-shi/image-20221203121536918-16700409382392.png" class=""><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><img src="/2022/12/03/java-ji-chu-zhi-shi/image-20221203121729965-16700410511833.png" class=""><h4 id="char-类型"><a href="#char-类型" class="headerlink" title="char 类型"></a>char 类型</h4><p>char 类型原本用于表示单个字符，char 类型的字面量值要用单引号括起来，例如：’A‘是编码值为 65 所对应的字符常量（注意这里是单引号，在java中双引号表示是字符串）</p><h4 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h4><p>boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>在 Java 中，每个变量都有一个类型（ type)。在声明变量时，变量的类型位于变量名之前</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> salary;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">long</span> id;</span><br><span class="line"><span class="type">boolean</span> done;</span><br></pre></td></tr></tbody></table></figure><p>每个声明以分号结束</p><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>声明变量后，如果要用到这个变量必须要进行显式的初始化，要不然会出现variable not initialized错误</p><p>要想对一个已经声明过的变量进行赋值， 就需要将变量名放在等号（=) 左侧， 相应取值 的 Java 表达式放在等号的右侧</p><p>可以先声明在调用的时候进行初始化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int number;</span><br><span class="line">number = 10;</span><br></pre></td></tr></tbody></table></figure><p>也可以在声明的时候就进行初始化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int number = 10;</span><br></pre></td></tr></tbody></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在Java中，可以利用关键字final来声明常量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI = 3.14;</span><br></pre></td></tr></tbody></table></figure><p>被final关键字修饰的变量只能被负值一次。一旦被赋值之后，就不能够再更改了。习惯上, 常量名使用全大写</p><h4 id="类常量"><a href="#类常量" class="headerlink" title="类常量"></a>类常量</h4><p>在一个类里面，main方法的外面，被关键字static final 修饰</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FirstSample{</span><br><span class="line">static final double PI = 3.14;</span><br><span class="line">public static void main(String[] args){</span><br><span class="line">System.out.println(PI);</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以被这个类的其它方法使用</p><p>如果类常量被声明为public则可以被其他类访问</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>+ 、-、 * 、/ 表示加、减、 乘、除运算</p><p>当参与 / 运算的两个操作数都是整数时， 表示整数除法；否则， 表示浮点除法。 整数的求余操作（有时称为取模) 用 ％ 表示。例如，15/2 等于 7 ，15%2 等于 1 , 15.0/2 等于 7.5</p><p>整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果</p><h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>在需要转换数值的类型或者不同类型的数值进行运算时</p><h5 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h5><p>会自动向更大的范围的类型转换，目的是为了防止精度丢失</p><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>大的范围的类型向小的范围的类型转换，会丢失精度</p><p>强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double a = 111.11;</span><br><span class="line">int aa = (int)a;</span><br></pre></td></tr></tbody></table></figure><p>在图中有 6 个实心箭头，表示无信息丢失的转换；有 3 个虚箭头， 表示可能有精度 损失的转换。</p><img src="/2022/12/03/java-ji-chu-zhi-shi/image-20221203130038510-16700436399064.png" class=""><p>注意：Math.round方法的返回值类型是long类型</p><h3 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h3><p>可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如</p><p>a += 4; 等价于 a = a + 4;</p><p>如果左右两边的操作数的类型不一样时会发生强制类型转换</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">a +=3.5; //等价于 (int)(a+3.5)   转换的类型以等号左边为准</span><br></pre></td></tr></tbody></table></figure><h3 id="关系和-boolean-运算符"><a href="#关系和-boolean-运算符" class="headerlink" title="关系和 boolean 运算符"></a>关系和 boolean 运算符</h3><p>==（等于）、!=（不等于）、&lt; (小于) 、&gt; (大于) 、&lt;=(小于等于）和 &gt;= (大于等于）</p><p>&amp;&amp; 表示逻辑“ 与” 运算符，使用丨| 表示逻辑“ 或” 运算 符</p><p>&amp;&amp; 和丨| 运算符是按照“ 短路” 方 式来求值的： 如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了 （a&amp;&amp;b）</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>语法： a?b:c</p><p>意思：判断a是否成立，如果成立执行b，不成立执行c</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>&amp; 按位与</p><p>| 按位或</p><p>^ 按位异或</p><p>~取反</p><p>&gt;&gt;右移</p><p>&lt;&lt;左移</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue快速安装</title>
      <link href="/2022/12/02/vue-kuai-su-an-zhuang/"/>
      <url>/2022/12/02/vue-kuai-su-an-zhuang/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一张图片</p><img src="/2022/12/02/vue-kuai-su-an-zhuang/image-20221202214952540.png" class="" title="image-20221202214952540">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/2022/12/02/bing-fa-bian-cheng/"/>
      <url>/2022/12/02/bing-fa-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Java如何处理并发编程"><a href="#Java如何处理并发编程" class="headerlink" title="Java如何处理并发编程"></a>Java如何处理并发编程</h1>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/02/hello-world/"/>
      <url>/2022/12/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2022/09/07/fan-she-ji-zhi/"/>
      <url>/2022/09/07/fan-she-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="# 反射机制"></a># 反射机制</h1>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea2021.3.1破解</title>
      <link href="/2021/12/04/idea2021-3-1-po-jie/"/>
      <url>/2021/12/04/idea2021-3-1-po-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="idea2021-3-1版本激活"><a href="#idea2021-3-1版本激活" class="headerlink" title="idea2021.3.1版本激活"></a>idea2021.3.1版本激活</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h2><p>下载的 IDEA 2021.3.1 <a href="https://www.jetbrains.com/idea/download/#section=windows">Download IntelliJ IDEA: The Capable &amp; Ergonomic Java IDE by JetBrains</a></p><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p>卸载老版本的 IDEA</p><h2 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h2><p>开始安装 IDEA 2021.3.1 版本（最好不要放在C盘）</p><h2 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h2><p>开始激活</p><p>点击 Start trial –&gt;点击 Login to JetBrains Account–&gt;注册一个 JetBrains–&gt;登录账号</p><h2 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h2><p>清空 IDEA 以前使用过的激活方式</p><p>之前安装过 IDEA, 且手动为 IDEA 修改过 hosts 文件，那么添加的配置，记得要删除；引用过的补丁也要移除掉等, 不然可能会与本文提供的补丁有冲突，出现各种奇奇怪怪的问题。</p><h2 id="第六步："><a href="#第六步：" class="headerlink" title="第六步："></a>第六步：</h2><p>依次点击菜单 Help -&gt; Edit Custom VM Options ， 修改 idea.vmoptions 文件在末尾添加下面代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:D:\\temp\\ja-netfilter\\ja-netfilter.jar (从D开始后面的是补丁的存放路径，修改成自己的)</span><br></pre></td></tr></tbody></table></figure><p>也可以在C:\Users\黄耀枫\AppData\Roaming\JetBrains\IntelliJIdea2021.3中找到idea64.exe.vmoptions文件，添加上面第六步</p><h2 id="第七步："><a href="#第七步：" class="headerlink" title="第七步："></a>第七步：</h2><p>重启idea</p><h2 id="效果截图："><a href="#效果截图：" class="headerlink" title="效果截图："></a>效果截图：</h2><img src="/2021/12/04/idea2021-3-1-po-jie/image-20221204175417424.png" class=""><h2 id="资源连接："><a href="#资源连接：" class="headerlink" title="资源连接："></a>资源连接：</h2><p>链接：<a href="https://pan.baidu.com/s/1sNv-vL9E5uyHnYODf3-WIQ">https://pan.baidu.com/s/1sNv-vL9E5uyHnYODf3-WIQ</a><br>提取码：2021 </p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>不要更新版本</p>]]></content>
      
      
      
        <tags>
            
            <tag> idea破解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
